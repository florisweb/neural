<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title></title>
		<style>
			body {
				position: fixed;
				margin: 0;
				padding: 0;
			}
			#graph {
				position: relative;
				height: 100vw;
				max-height: 100vh;
				width: auto;
				border: 1px solid red;
				margin-bottom: -40px;
			}
		</style>
	</head>
	<body>
		<canvas id='graph' width='500' height="500"></canvas>
		<div id='errorHolder'></div>
		<script type="text/javascript" src='vector.js'></script>
		<script type="text/javascript" src='matrix.js'></script>
		<script type="text/javascript" src='functionDrawer.js'></script>
		<script type="text/javascript" src='neuralNetwork.js'></script>
		<script type="text/javascript" src='perceptron.js'></script>

		<script>
		
			



			let NN = new NeuralNetwork([1, 5, 3, 1]);

			let dataPoints = [];






			function train() {
				if (!dataPoints.length) return;

				let summedChanges;
				let summedError = 0;

				for (let point of dataPoints)
				{
					let changeSet = NN.calcChanges(point.inputs, point.outputs);
					summedError += changeSet.error;
					if (!summedChanges) 
					{
						summedChanges = changeSet.changes;
						continue;
					}

					for (let l = 1; l < changeSet.changes.length; l++)
					{
						summedChanges[l].weights.add(changeSet.changes[l].weights);
						summedChanges[l].biases.add(changeSet.changes[l].biases);
					}
				}

				for (let l = 1; l < summedChanges.length; l++)
				{
					summedChanges[l].weights.scale(1 / dataPoints.length);
					summedChanges[l].biases.scale(1 / dataPoints.length);
				}

				NN.applyChanges(summedChanges);
			}

			function calcError() {
				let summedError = 0;

				for (let point of dataPoints)
				{
					summedError += NN.calcTotalError(point.inputs, point.outputs);
				}
				return summedError / dataPoints.length;
			}



			function runner() {
				let start = new Date();
				for (let i = 0; i < 3000; i++) train();
				
				FD.drawFunction(f);
				for (let point of dataPoints) 
				{
					FD.drawPoint(new Vector(point.inputs.value[0][0], point.outputs.value[0][0]), '#f0f', 10)
				}

				errorHolder.innerHTML = 'Error: ' + calcError() + ' dT: ' + (new Date() - start) + 'ms';

				requestAnimationFrame(runner);
			}









			// let actualFunction = (x) => 2 * x;
			// let actualFunction = (x) => .5 * x + .1;

			// let perceptron = new Perceptron();



			// let m = new Matrix(5, 1, 2);



			
			// const steps = 10;
			// const learningRate = .1;

			// function tune() {
			// 	let sumdB = 0;
			// 	let sumdW = 0;
			// 	for (let x = 0; x < 1; x += 1 / steps)
			// 	{	
			// 		let changes = perceptron.calcChanges(x, actualFunction(x));
			// 		sumdW += changes.dW;
			// 		sumdB += changes.dB;
			// 	}

			// 	let dW = sumdW / steps * learningRate;
			// 	let dB = sumdB / steps * learningRate;

			// 	perceptron.bias -= dB;
			// 	perceptron.weight -= dW;

			// }

			// function train(_rounds = 100) {
			// 	let startError = calcAverageError(steps);
			// 	for (let i = 0; i < _rounds; i++) tune();
			// 	console.log('start: ' + startError, 'end: ' + calcAverageError(steps));
			// }




			// function calcAverageError(_steps = 10) {
			// 	let sumError = 0;
			// 	for (let x = 0; x < 1; x += 1 / _steps)
			// 	{	
			// 		sumError += perceptron.calcChanges(x, actualFunction(x)).error;
			// 	}

			// 	return sumError / _steps;
			// }


			





			// f = (x, y) => perceptron.calcActivation(x) > y;









			// const a = .5;
			// const b = .3;
			// f = (x, y) => a * x + b > y;
			// f = (x, y) => (x - .5)**2 + (y - .5)**2 < .2**2;
			// f = (x, y) => Math.sin(x * Math.PI * 5) / 4 + .5 > y;
		

			// let f = (x, y) => NN.calcOutput(new Matrix().fromArray([[x], [y]])).value[0][0] > .5;
			let f = (x, y) => NN.calcOutput(new Matrix().fromArray([[x]])).value[0][0] > y;



			let FD = new FunctionDrawer(graph);
			const xDomain = new Vector(0, 1);
			const yDomain = new Vector(0, 1);
			FD.setDomain(xDomain, yDomain);
			



			graph.onclick = function(_e) {
				let pos = FD.pxToPos(new Vector(_e.clientX / graph.offsetWidth * graph.width, _e.clientY / graph.offsetHeight * graph.height));
				// let dataPoint = {
				// 	inputs: new Matrix().fromArray([pos.value]).transpose(),
				// 	outputs: new Matrix().fromArray([[_e.shiftKey ? 0 : 1]])
				// }

				let dataPoint = {
					inputs: new Matrix().fromArray([[pos.value[0]]]),
					outputs: new Matrix().fromArray([[pos.value[1]]])
				}
				dataPoints.push(dataPoint);
			}
			






			runner();
		</script>
	</body>
</html>